# Snapshot report for `__tests__/loader.js`

The actual snapshot is saved in `loader.js.snap`.

Generated by [AVA](https://ava.li).

## template-one-element renders one element

> Snapshot 1

    `<html><head>␊
        <title></title>␊
      <script>/* CustomElementOne.html generated by Svelte v2.16.1 */␊
    var XRJZPMDR = (function() { "use strict";␊
    ␊
    	function data() {␊
    	return {␊
    		name: 'Dave' ␊
    	};␊
    };␊
    ␊
    	function create_main_fragment(component, ctx) {␊
    		var span, text0, text1, text2;␊
    ␊
    		return {␊
    			c() {␊
    				span = createElement("span");␊
    				text0 = createText("Hello, there ");␊
    				text1 = createText(ctx.name);␊
    				text2 = createText("!");␊
    			},␊
    ␊
    			l(nodes) {␊
    				span = claimElement(nodes, "SPAN", {}, false);␊
    				var span_nodes = children(span);␊
    ␊
    				text0 = claimText(span_nodes, "Hello, there ");␊
    				text1 = claimText(span_nodes, ctx.name);␊
    				text2 = claimText(span_nodes, "!");␊
    				span_nodes.forEach(detachNode);␊
    			},␊
    ␊
    			m(target, anchor) {␊
    				insert(target, span, anchor);␊
    				append(span, text0);␊
    				append(span, text1);␊
    				append(span, text2);␊
    			},␊
    ␊
    			p(changed, ctx) {␊
    				if (changed.name) {␊
    					setData(text1, ctx.name);␊
    				}␊
    			},␊
    ␊
    			d(detach) {␊
    				if (detach) {␊
    					detachNode(span);␊
    				}␊
    			}␊
    		};␊
    	}␊
    ␊
    	function XRJZPMDR(options) {␊
    		init(this, options);␊
    		this._state = assign(data(), options.data);␊
    		this._intro = true;␊
    ␊
    		this._fragment = create_main_fragment(this, this._state);␊
    ␊
    		if (options.target) {␊
    			var nodes = children(options.target);␊
    			options.hydrate ? this._fragment.l(nodes) : this._fragment.c();␊
    			nodes.forEach(detachNode);␊
    			this._mount(options.target, options.anchor);␊
    		}␊
    	}␊
    ␊
    	assign(XRJZPMDR.prototype, {␊
    	 	destroy: destroy,␊
    	 	get: get,␊
    	 	fire: fire,␊
    	 	on: on,␊
    	 	set: set,␊
    	 	_set: _set,␊
    	 	_stage: _stage,␊
    	 	_mount: _mount,␊
    	 	_differs: _differs␊
    	 });␊
    ␊
    	XRJZPMDR.prototype._recompute = noop;␊
    ␊
    	function createElement(name) {␊
    		return document.createElement(name);␊
    	}␊
    ␊
    	function createText(data) {␊
    		return document.createTextNode(data);␊
    	}␊
    ␊
    	function claimElement (nodes, name, attributes, svg) {␊
    		for (var i = 0; i < nodes.length; i += 1) {␊
    			var node = nodes[i];␊
    			if (node.nodeName === name) {␊
    				for (var j = 0; j < node.attributes.length; j += 1) {␊
    					var attribute = node.attributes[j];␊
    					if (!attributes[attribute.name]) node.removeAttribute(attribute.name);␊
    				}␊
    				return nodes.splice(i, 1)[0]; // TODO strip unwanted attributes␊
    			}␊
    		}␊
    ␊
    		return svg ? createSvgElement(name) : createElement(name);␊
    	}␊
    ␊
    	function children (element) {␊
    		return Array.from(element.childNodes);␊
    	}␊
    ␊
    	function claimText (nodes, data) {␊
    		for (var i = 0; i < nodes.length; i += 1) {␊
    			var node = nodes[i];␊
    			if (node.nodeType === 3) {␊
    				node.data = data;␊
    				return nodes.splice(i, 1)[0];␊
    			}␊
    		}␊
    ␊
    		return createText(data);␊
    	}␊
    ␊
    	function detachNode(node) {␊
    		node.parentNode.removeChild(node);␊
    	}␊
    ␊
    	function insert(target, node, anchor) {␊
    		target.insertBefore(node, anchor);␊
    	}␊
    ␊
    	function append(target, node) {␊
    		target.appendChild(node);␊
    	}␊
    ␊
    	function setData(text, data) {␊
    		text.data = '' + data;␊
    	}␊
    ␊
    	function init(component, options) {␊
    		component._handlers = blankObject();␊
    		component._slots = blankObject();␊
    		component._bind = options._bind;␊
    		component._staged = {};␊
    ␊
    		component.options = options;␊
    		component.root = options.root || component;␊
    		component.store = options.store || component.root.store;␊
    ␊
    		if (!options.root) {␊
    			component._beforecreate = [];␊
    			component._oncreate = [];␊
    			component._aftercreate = [];␊
    		}␊
    	}␊
    ␊
    	function assign(tar, src) {␊
    		for (var k in src) tar[k] = src[k];␊
    		return tar;␊
    	}␊
    ␊
    	function destroy(detach) {␊
    		this.destroy = noop;␊
    		this.fire('destroy');␊
    		this.set = noop;␊
    ␊
    		this._fragment.d(detach !== false);␊
    		this._fragment = null;␊
    		this._state = {};␊
    	}␊
    ␊
    	function get() {␊
    		return this._state;␊
    	}␊
    ␊
    	function fire(eventName, data) {␊
    		var handlers =␊
    			eventName in this._handlers && this._handlers[eventName].slice();␊
    		if (!handlers) return;␊
    ␊
    		for (var i = 0; i < handlers.length; i += 1) {␊
    			var handler = handlers[i];␊
    ␊
    			if (!handler.__calling) {␊
    				try {␊
    					handler.__calling = true;␊
    					handler.call(this, data);␊
    				} finally {␊
    					handler.__calling = false;␊
    				}␊
    			}␊
    		}␊
    	}␊
    ␊
    	function on(eventName, handler) {␊
    		var handlers = this._handlers[eventName] || (this._handlers[eventName] = []);␊
    		handlers.push(handler);␊
    ␊
    		return {␊
    			cancel: function() {␊
    				var index = handlers.indexOf(handler);␊
    				if (~index) handlers.splice(index, 1);␊
    			}␊
    		};␊
    	}␊
    ␊
    	function set(newState) {␊
    		this._set(assign({}, newState));␊
    		if (this.root._lock) return;␊
    		flush(this.root);␊
    	}␊
    ␊
    	function _set(newState) {␊
    		var oldState = this._state,␊
    			changed = {},␊
    			dirty = false;␊
    ␊
    		newState = assign(this._staged, newState);␊
    		this._staged = {};␊
    ␊
    		for (var key in newState) {␊
    			if (this._differs(newState[key], oldState[key])) changed[key] = dirty = true;␊
    		}␊
    		if (!dirty) return;␊
    ␊
    		this._state = assign(assign({}, oldState), newState);␊
    		this._recompute(changed, this._state);␊
    		if (this._bind) this._bind(changed, this._state);␊
    ␊
    		if (this._fragment) {␊
    			this.fire("state", { changed: changed, current: this._state, previous: oldState });␊
    			this._fragment.p(changed, this._state);␊
    			this.fire("update", { changed: changed, current: this._state, previous: oldState });␊
    		}␊
    	}␊
    ␊
    	function _stage(newState) {␊
    		assign(this._staged, newState);␊
    	}␊
    ␊
    	function _mount(target, anchor) {␊
    		this._fragment[this._fragment.i ? 'i' : 'm'](target, anchor || null);␊
    	}␊
    ␊
    	function _differs(a, b) {␊
    		return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');␊
    	}␊
    ␊
    	function noop() {}␊
    ␊
    	function createSvgElement(name) {␊
    		return document.createElementNS('http://www.w3.org/2000/svg', name);␊
    	}␊
    ␊
    	function blankObject() {␊
    		return Object.create(null);␊
    	}␊
    ␊
    	function flush(component) {␊
    		component._lock = true;␊
    		callAll(component._beforecreate);␊
    		callAll(component._oncreate);␊
    		callAll(component._aftercreate);␊
    		component._lock = false;␊
    	}␊
    ␊
    	function callAll(fns) {␊
    		while (fns && fns.length) fns.shift()();␊
    	}␊
    	return XRJZPMDR;␊
    }());</script></head>␊
      <body><span id="belte-0">Hello, there Dave! </span><script>␊
        new XRJZPMDR({␊
        target:document.getElementById('belte-0'),␊
        hydrate:true,data:{}}␊
      );</script></body></html>`

## template-three-multiple can render multiple components

> Snapshot 1

    `<html><head>␊
        <title></title>␊
      <script>/* CustomElementOne.html generated by Svelte v2.16.1 */␊
    var XRJZPMDR = (function() { "use strict";␊
    ␊
    	function data() {␊
    	return {␊
    		name: 'Dave' ␊
    	};␊
    };␊
    ␊
    	function create_main_fragment(component, ctx) {␊
    		var span, text0, text1, text2;␊
    ␊
    		return {␊
    			c() {␊
    				span = createElement("span");␊
    				text0 = createText("Hello, there ");␊
    				text1 = createText(ctx.name);␊
    				text2 = createText("!");␊
    			},␊
    ␊
    			l(nodes) {␊
    				span = claimElement(nodes, "SPAN", {}, false);␊
    				var span_nodes = children(span);␊
    ␊
    				text0 = claimText(span_nodes, "Hello, there ");␊
    				text1 = claimText(span_nodes, ctx.name);␊
    				text2 = claimText(span_nodes, "!");␊
    				span_nodes.forEach(detachNode);␊
    			},␊
    ␊
    			m(target, anchor) {␊
    				insert(target, span, anchor);␊
    				append(span, text0);␊
    				append(span, text1);␊
    				append(span, text2);␊
    			},␊
    ␊
    			p(changed, ctx) {␊
    				if (changed.name) {␊
    					setData(text1, ctx.name);␊
    				}␊
    			},␊
    ␊
    			d(detach) {␊
    				if (detach) {␊
    					detachNode(span);␊
    				}␊
    			}␊
    		};␊
    	}␊
    ␊
    	function XRJZPMDR(options) {␊
    		init(this, options);␊
    		this._state = assign(data(), options.data);␊
    		this._intro = true;␊
    ␊
    		this._fragment = create_main_fragment(this, this._state);␊
    ␊
    		if (options.target) {␊
    			var nodes = children(options.target);␊
    			options.hydrate ? this._fragment.l(nodes) : this._fragment.c();␊
    			nodes.forEach(detachNode);␊
    			this._mount(options.target, options.anchor);␊
    		}␊
    	}␊
    ␊
    	assign(XRJZPMDR.prototype, {␊
    	 	destroy: destroy,␊
    	 	get: get,␊
    	 	fire: fire,␊
    	 	on: on,␊
    	 	set: set,␊
    	 	_set: _set,␊
    	 	_stage: _stage,␊
    	 	_mount: _mount,␊
    	 	_differs: _differs␊
    	 });␊
    ␊
    	XRJZPMDR.prototype._recompute = noop;␊
    ␊
    	function createElement(name) {␊
    		return document.createElement(name);␊
    	}␊
    ␊
    	function createText(data) {␊
    		return document.createTextNode(data);␊
    	}␊
    ␊
    	function claimElement (nodes, name, attributes, svg) {␊
    		for (var i = 0; i < nodes.length; i += 1) {␊
    			var node = nodes[i];␊
    			if (node.nodeName === name) {␊
    				for (var j = 0; j < node.attributes.length; j += 1) {␊
    					var attribute = node.attributes[j];␊
    					if (!attributes[attribute.name]) node.removeAttribute(attribute.name);␊
    				}␊
    				return nodes.splice(i, 1)[0]; // TODO strip unwanted attributes␊
    			}␊
    		}␊
    ␊
    		return svg ? createSvgElement(name) : createElement(name);␊
    	}␊
    ␊
    	function children (element) {␊
    		return Array.from(element.childNodes);␊
    	}␊
    ␊
    	function claimText (nodes, data) {␊
    		for (var i = 0; i < nodes.length; i += 1) {␊
    			var node = nodes[i];␊
    			if (node.nodeType === 3) {␊
    				node.data = data;␊
    				return nodes.splice(i, 1)[0];␊
    			}␊
    		}␊
    ␊
    		return createText(data);␊
    	}␊
    ␊
    	function detachNode(node) {␊
    		node.parentNode.removeChild(node);␊
    	}␊
    ␊
    	function insert(target, node, anchor) {␊
    		target.insertBefore(node, anchor);␊
    	}␊
    ␊
    	function append(target, node) {␊
    		target.appendChild(node);␊
    	}␊
    ␊
    	function setData(text, data) {␊
    		text.data = '' + data;␊
    	}␊
    ␊
    	function init(component, options) {␊
    		component._handlers = blankObject();␊
    		component._slots = blankObject();␊
    		component._bind = options._bind;␊
    		component._staged = {};␊
    ␊
    		component.options = options;␊
    		component.root = options.root || component;␊
    		component.store = options.store || component.root.store;␊
    ␊
    		if (!options.root) {␊
    			component._beforecreate = [];␊
    			component._oncreate = [];␊
    			component._aftercreate = [];␊
    		}␊
    	}␊
    ␊
    	function assign(tar, src) {␊
    		for (var k in src) tar[k] = src[k];␊
    		return tar;␊
    	}␊
    ␊
    	function destroy(detach) {␊
    		this.destroy = noop;␊
    		this.fire('destroy');␊
    		this.set = noop;␊
    ␊
    		this._fragment.d(detach !== false);␊
    		this._fragment = null;␊
    		this._state = {};␊
    	}␊
    ␊
    	function get() {␊
    		return this._state;␊
    	}␊
    ␊
    	function fire(eventName, data) {␊
    		var handlers =␊
    			eventName in this._handlers && this._handlers[eventName].slice();␊
    		if (!handlers) return;␊
    ␊
    		for (var i = 0; i < handlers.length; i += 1) {␊
    			var handler = handlers[i];␊
    ␊
    			if (!handler.__calling) {␊
    				try {␊
    					handler.__calling = true;␊
    					handler.call(this, data);␊
    				} finally {␊
    					handler.__calling = false;␊
    				}␊
    			}␊
    		}␊
    	}␊
    ␊
    	function on(eventName, handler) {␊
    		var handlers = this._handlers[eventName] || (this._handlers[eventName] = []);␊
    		handlers.push(handler);␊
    ␊
    		return {␊
    			cancel: function() {␊
    				var index = handlers.indexOf(handler);␊
    				if (~index) handlers.splice(index, 1);␊
    			}␊
    		};␊
    	}␊
    ␊
    	function set(newState) {␊
    		this._set(assign({}, newState));␊
    		if (this.root._lock) return;␊
    		flush(this.root);␊
    	}␊
    ␊
    	function _set(newState) {␊
    		var oldState = this._state,␊
    			changed = {},␊
    			dirty = false;␊
    ␊
    		newState = assign(this._staged, newState);␊
    		this._staged = {};␊
    ␊
    		for (var key in newState) {␊
    			if (this._differs(newState[key], oldState[key])) changed[key] = dirty = true;␊
    		}␊
    		if (!dirty) return;␊
    ␊
    		this._state = assign(assign({}, oldState), newState);␊
    		this._recompute(changed, this._state);␊
    		if (this._bind) this._bind(changed, this._state);␊
    ␊
    		if (this._fragment) {␊
    			this.fire("state", { changed: changed, current: this._state, previous: oldState });␊
    			this._fragment.p(changed, this._state);␊
    			this.fire("update", { changed: changed, current: this._state, previous: oldState });␊
    		}␊
    	}␊
    ␊
    	function _stage(newState) {␊
    		assign(this._staged, newState);␊
    	}␊
    ␊
    	function _mount(target, anchor) {␊
    		this._fragment[this._fragment.i ? 'i' : 'm'](target, anchor || null);␊
    	}␊
    ␊
    	function _differs(a, b) {␊
    		return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');␊
    	}␊
    ␊
    	function noop() {}␊
    ␊
    	function createSvgElement(name) {␊
    		return document.createElementNS('http://www.w3.org/2000/svg', name);␊
    	}␊
    ␊
    	function blankObject() {␊
    		return Object.create(null);␊
    	}␊
    ␊
    	function flush(component) {␊
    		component._lock = true;␊
    		callAll(component._beforecreate);␊
    		callAll(component._oncreate);␊
    		callAll(component._aftercreate);␊
    		component._lock = false;␊
    	}␊
    ␊
    	function callAll(fns) {␊
    		while (fns && fns.length) fns.shift()();␊
    	}␊
    	return XRJZPMDR;␊
    }());</script></head>␊
      <body><span id="belte-0">Hello, there Dave! </span><script>␊
        new XRJZPMDR({␊
        target:document.getElementById('belte-0'),␊
        hydrate:true,data:{}}␊
      );</script></body></html>`

## template-two-attributes renders one element with attributes

> Snapshot 1

    `<html><head>␊
        <title></title>␊
      <script>/* CustomElementOne.html generated by Svelte v2.16.1 */␊
    var XRJZPMDR = (function() { "use strict";␊
    ␊
    	function data() {␊
    	return {␊
    		name: 'Dave' ␊
    	};␊
    };␊
    ␊
    	function create_main_fragment(component, ctx) {␊
    		var span, text0, text1, text2;␊
    ␊
    		return {␊
    			c() {␊
    				span = createElement("span");␊
    				text0 = createText("Hello, there ");␊
    				text1 = createText(ctx.name);␊
    				text2 = createText("!");␊
    			},␊
    ␊
    			l(nodes) {␊
    				span = claimElement(nodes, "SPAN", {}, false);␊
    				var span_nodes = children(span);␊
    ␊
    				text0 = claimText(span_nodes, "Hello, there ");␊
    				text1 = claimText(span_nodes, ctx.name);␊
    				text2 = claimText(span_nodes, "!");␊
    				span_nodes.forEach(detachNode);␊
    			},␊
    ␊
    			m(target, anchor) {␊
    				insert(target, span, anchor);␊
    				append(span, text0);␊
    				append(span, text1);␊
    				append(span, text2);␊
    			},␊
    ␊
    			p(changed, ctx) {␊
    				if (changed.name) {␊
    					setData(text1, ctx.name);␊
    				}␊
    			},␊
    ␊
    			d(detach) {␊
    				if (detach) {␊
    					detachNode(span);␊
    				}␊
    			}␊
    		};␊
    	}␊
    ␊
    	function XRJZPMDR(options) {␊
    		init(this, options);␊
    		this._state = assign(data(), options.data);␊
    		this._intro = true;␊
    ␊
    		this._fragment = create_main_fragment(this, this._state);␊
    ␊
    		if (options.target) {␊
    			var nodes = children(options.target);␊
    			options.hydrate ? this._fragment.l(nodes) : this._fragment.c();␊
    			nodes.forEach(detachNode);␊
    			this._mount(options.target, options.anchor);␊
    		}␊
    	}␊
    ␊
    	assign(XRJZPMDR.prototype, {␊
    	 	destroy: destroy,␊
    	 	get: get,␊
    	 	fire: fire,␊
    	 	on: on,␊
    	 	set: set,␊
    	 	_set: _set,␊
    	 	_stage: _stage,␊
    	 	_mount: _mount,␊
    	 	_differs: _differs␊
    	 });␊
    ␊
    	XRJZPMDR.prototype._recompute = noop;␊
    ␊
    	function createElement(name) {␊
    		return document.createElement(name);␊
    	}␊
    ␊
    	function createText(data) {␊
    		return document.createTextNode(data);␊
    	}␊
    ␊
    	function claimElement (nodes, name, attributes, svg) {␊
    		for (var i = 0; i < nodes.length; i += 1) {␊
    			var node = nodes[i];␊
    			if (node.nodeName === name) {␊
    				for (var j = 0; j < node.attributes.length; j += 1) {␊
    					var attribute = node.attributes[j];␊
    					if (!attributes[attribute.name]) node.removeAttribute(attribute.name);␊
    				}␊
    				return nodes.splice(i, 1)[0]; // TODO strip unwanted attributes␊
    			}␊
    		}␊
    ␊
    		return svg ? createSvgElement(name) : createElement(name);␊
    	}␊
    ␊
    	function children (element) {␊
    		return Array.from(element.childNodes);␊
    	}␊
    ␊
    	function claimText (nodes, data) {␊
    		for (var i = 0; i < nodes.length; i += 1) {␊
    			var node = nodes[i];␊
    			if (node.nodeType === 3) {␊
    				node.data = data;␊
    				return nodes.splice(i, 1)[0];␊
    			}␊
    		}␊
    ␊
    		return createText(data);␊
    	}␊
    ␊
    	function detachNode(node) {␊
    		node.parentNode.removeChild(node);␊
    	}␊
    ␊
    	function insert(target, node, anchor) {␊
    		target.insertBefore(node, anchor);␊
    	}␊
    ␊
    	function append(target, node) {␊
    		target.appendChild(node);␊
    	}␊
    ␊
    	function setData(text, data) {␊
    		text.data = '' + data;␊
    	}␊
    ␊
    	function init(component, options) {␊
    		component._handlers = blankObject();␊
    		component._slots = blankObject();␊
    		component._bind = options._bind;␊
    		component._staged = {};␊
    ␊
    		component.options = options;␊
    		component.root = options.root || component;␊
    		component.store = options.store || component.root.store;␊
    ␊
    		if (!options.root) {␊
    			component._beforecreate = [];␊
    			component._oncreate = [];␊
    			component._aftercreate = [];␊
    		}␊
    	}␊
    ␊
    	function assign(tar, src) {␊
    		for (var k in src) tar[k] = src[k];␊
    		return tar;␊
    	}␊
    ␊
    	function destroy(detach) {␊
    		this.destroy = noop;␊
    		this.fire('destroy');␊
    		this.set = noop;␊
    ␊
    		this._fragment.d(detach !== false);␊
    		this._fragment = null;␊
    		this._state = {};␊
    	}␊
    ␊
    	function get() {␊
    		return this._state;␊
    	}␊
    ␊
    	function fire(eventName, data) {␊
    		var handlers =␊
    			eventName in this._handlers && this._handlers[eventName].slice();␊
    		if (!handlers) return;␊
    ␊
    		for (var i = 0; i < handlers.length; i += 1) {␊
    			var handler = handlers[i];␊
    ␊
    			if (!handler.__calling) {␊
    				try {␊
    					handler.__calling = true;␊
    					handler.call(this, data);␊
    				} finally {␊
    					handler.__calling = false;␊
    				}␊
    			}␊
    		}␊
    	}␊
    ␊
    	function on(eventName, handler) {␊
    		var handlers = this._handlers[eventName] || (this._handlers[eventName] = []);␊
    		handlers.push(handler);␊
    ␊
    		return {␊
    			cancel: function() {␊
    				var index = handlers.indexOf(handler);␊
    				if (~index) handlers.splice(index, 1);␊
    			}␊
    		};␊
    	}␊
    ␊
    	function set(newState) {␊
    		this._set(assign({}, newState));␊
    		if (this.root._lock) return;␊
    		flush(this.root);␊
    	}␊
    ␊
    	function _set(newState) {␊
    		var oldState = this._state,␊
    			changed = {},␊
    			dirty = false;␊
    ␊
    		newState = assign(this._staged, newState);␊
    		this._staged = {};␊
    ␊
    		for (var key in newState) {␊
    			if (this._differs(newState[key], oldState[key])) changed[key] = dirty = true;␊
    		}␊
    		if (!dirty) return;␊
    ␊
    		this._state = assign(assign({}, oldState), newState);␊
    		this._recompute(changed, this._state);␊
    		if (this._bind) this._bind(changed, this._state);␊
    ␊
    		if (this._fragment) {␊
    			this.fire("state", { changed: changed, current: this._state, previous: oldState });␊
    			this._fragment.p(changed, this._state);␊
    			this.fire("update", { changed: changed, current: this._state, previous: oldState });␊
    		}␊
    	}␊
    ␊
    	function _stage(newState) {␊
    		assign(this._staged, newState);␊
    	}␊
    ␊
    	function _mount(target, anchor) {␊
    		this._fragment[this._fragment.i ? 'i' : 'm'](target, anchor || null);␊
    	}␊
    ␊
    	function _differs(a, b) {␊
    		return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');␊
    	}␊
    ␊
    	function noop() {}␊
    ␊
    	function createSvgElement(name) {␊
    		return document.createElementNS('http://www.w3.org/2000/svg', name);␊
    	}␊
    ␊
    	function blankObject() {␊
    		return Object.create(null);␊
    	}␊
    ␊
    	function flush(component) {␊
    		component._lock = true;␊
    		callAll(component._beforecreate);␊
    		callAll(component._oncreate);␊
    		callAll(component._aftercreate);␊
    		component._lock = false;␊
    	}␊
    ␊
    	function callAll(fns) {␊
    		while (fns && fns.length) fns.shift()();␊
    	}␊
    	return XRJZPMDR;␊
    }());</script></head>␊
      <body><span id="belte-0">Hello, there John Collins! </span><script>␊
        new XRJZPMDR({␊
        target:document.getElementById('belte-0'),␊
        hydrate:true,data:{"name":"John Collins"}}␊
      );</script></body></html>`
